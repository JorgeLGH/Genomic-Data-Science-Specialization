---
title: "Python for Genomic Data Science"
author: "Jorge Luis GÃ³mez"
date: "`r Sys.Date()`"
output:
  html_document: 
    fig_height: 8
    fig_width: 13
    number_section: yes
    theme: cerulean
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
  pdf_document:
    toc: yesT
  word_document:
    toc: yes
---
# Resources

1. We can work directly with the SandBox service Coursera offers completely free with the course. It is available at [this](https://www.coursera.org/learn/python-genomics/lab-sandbox?path=%2Ftree) location.

2. The official [Python](https://www.python.org) site.

3. A tutorial by Patrick O'Brien named "Beginning Python for Bioinformatics".

4. Introduction to Programming using Python by the Pasteur Institute

5. An interactive site for learning [Python](https://learnpython.org)

6. The book "Think Python" 2nd Edition by Allen B. Downey which can be found [here](Think Python 2nd Edition by Allen B. Downey)

# Module 1

## Overview of Python

The approaches of learning how to program can be as diverse as taking classes, asking for help, read a book, or even read someone else's code. There are some programming strategies we can follow.

- Identify the inputs and data specification
- Provide all the data and design how and which steps the computer will follow
- Decide the output you want to have, what we want to be displayed
- Refine the program and give more details
- Actually write the program

The more complex programs can be designed with a little more ease if you apply some strategies such as writing a pseudo code. A pseudo code has normal text and semantics, but will try to describe the process our final code will execute.

Python is an actual programming language. It is very popular and it is easy to learn compared to other languages. It has efficient data structures and simple object-oriented programming, making it more accessible. A very important feature is that is is an interpreted language, meaning it will not have to compile before executing it; we run it directly from our line of code; the drawback is that due to the nature of being interpreted, the speed will be an issue.

Python is easy and simple to use, having a more simple and defined syntax that makes it readable; it will also be shorter than other languages. As said before, it is an interpreted language. It has lots of built-in functions and libraries available. It can run regardless of the used OS in the computer. It can be used as an extension language that communicates, for example, with more complex programs in other languages. It can also be used for both large and complex tasks, as well as simple ones. 

## First Steps Toward Programming Part 1

We'll start with the basics, the `numbers` and `string` data types.

Firstly, we'll learn how to use python as a computer, since it has some important differences, for example, to the language R. 

### Numbers

```{python}
# For adding, we can do it directly
5+5
```

```{python}
# The * means multiplication
10*2
```

```{python}
# Double * represents powers
10**2
```

```{python}
# Double // only yields the integer without the fractional part of a division
17//3
```

```{python}
# The % operator will return just the remainder after a division
15%2

# Python follows mathematical languages, so that, for example * takes precedence before +,-
```

Numbers have different types, like integers, which are just round numbers; but we can have real numbers with fractions, etc. We can check the number types with specific commands in Python.

```{python}
# Integers
type(5)
```

```{python}
# real numbers
type(3.5) # it will have the name 'float' which refers to numbers with fractions
```

```{python}
# complex numbers
type(3+2j)
```

### Strings

They are specific data structures used in genomic sciences since, for example, the genomic code is a string of the same 4 different characters. We can create strings with single or double quotes like this **"",'' **. The most common use is double quotes when using normal speech. To avoid errors with single quotes, for a character not to be counted as the end of the string, we add a **/** before the character itself. For multiple lines of characters to be considered as a single string, we can ad triple quotes before writing, and the the same after the lines themselves; each triple quotes on their own lines ('''    ''').

Another interesting thing is the use of escape characters, which give special meanings to lines depending on how you use the. For example.

| Construct    | Meaning     |
| ------------ | ----------- |
| \\n          | New line    |
| \\t          | Tab         |
| \\\          | Backslash   |
| \\"          | Double quote|

In order to print more nicely, we can use the command `print()` in order to produce more readable outputs by omitting and enclosing quotes by printing escaped and special characters. It can be shown as follows.

```{python}
print(""" 
>dna1
actgactgatgctgctgatgc
tagctgatcgtagctgc
>dna2
tgactgatcgatgctgacttgactgtgac
""")
```

Without the backslash at the end of the first triple quotes, the end of a line is directly included into the string. 

### Basic operators

We have a myriad of operators for us to manipulate the strings as we want.

```{python}
# concatenate strings
"atg"+"ctg"
```

```{python}
# copy/replicate strings
"atg"*3
```

```{python}
# membership: true if first string exist inside the second string
"atg" in "tatgtcgagtatgctgatatg"
```

```{python}
# non-membership: true if the first string does not exist in the second one
"atg" in "my name is luis"
```

## First Steps Towards Programming Part 2

### Variables

Variables are the *storage containers* for our data, no matter the type or structure. The **=** sign is used to assign a value to a variable.

```{python}
codon = "atg"

dna_sequence = "atgctgctgatgtgctga"
```

As shown, if if is not order to Python, then it will not return the values we assigned to our variables, meaning they exist, but are not shown. In the same fashion, typing an unexisting/undefined name of a variable will just send an error. We can change the values to the same variable, which can overwrite the value, or even copy the value from a variable into another.

```{r}
a = 4
a

b = a
b

b = b+3
b
```

Generally speaking, the name of the variables must have meaningful names, so it can be understood by others and yourself in later times. Python is case-sensitive, so we must pay attention when defining our variables. We have to account that some characters cannot be used in the variables' names, such as special characters and numbers as the first character of the variable's name.

We can also try to find specific positions or locations of a string without having to print the whole string. Indexing refers to selecting the character at position *x* that has been selected. Slicing refers to making a substring form the original between the selected *x* and *y* positions. It is important to note that the string in Python, and some other languages, start at number 0 rather than 1.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna[0]
dna[0:3]
dna[:3]
dna[2:]
```

In the previous slicing example, we want to select the first 3 characters from our string. We may think it would consider the first 4 characters since we begin in 0, but the 3 at the end of the slice means it will take everything **before** the specified end of the slice. 

We can also select negative numbers, which start counting from the right, meaning the end of the string.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

# the last character
dna[-1]
```

When we wish to know the length of our strings, we can use the function `len()` to directly return the length. 

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

len(dna)
```

There are many other functions that can be used for a variety of reasons and scenarios, such as `type()` and `print()`. If any questions arise and we need more information about the function, we can simply type `help(name_of_function)` and it will give us more information.

Our variables are objects too, so we can make more with them. Specific functions and actions can be performed onto our variables, these are called *methods*. For example, we can use the function `name_of_variable.count()` to count how many times does a character repeat itself in the string.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna.count("c")
dna.count("gc")
```

Other examples include the change of lower-case to upper-case characters and vice-versa. Even finding substring can be done with the method `.find()`, this will yield the position in which the specified substring starts in the original, but only the first one; we can change where it starts looking with parameters, even starting from the end.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna.upper()

dna.find("atgc")
dna.find("atcg",11)
dna.rfind("tta")
```

Other functions do not modify the string, but analyse what it contains and gives us more information. To exemplify, the functions `.islower()` and `.isupper()` both will tell us if our string complies with the rules, in this case, if the string is in upper or lower-case letters.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna.islower()
dna.isupper()
```

Another useful string method is replacing certain characters for others.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna.replace("a","A")
```

## First Steps Toward Programming Part 3

We'll make the first program using Python in this lecture. Starting from the creation of the pseudo code that will later be translated into actual code for us to determine the GC's concentration in a string. First of all, we'll declare the "dna" variable which will contain the sequence in question.

```{python}
# read DNA sequence from user
dna = "atcgtgatcgatgctagctagtagctagctgactagtcgatcgatcgtagc"
```

```{python}
# count the number of C's in the DNA sequence
no_c = dna.count("c")
```

```{python}
# count the number of G's in the DNA sequence
no_g = dna.count("g")
```

```{python}
# determine the length of the DNA sequence
dna_len = len(dna)
```

```{python}
# compute the GC percentage
gc_percent = (no_c+no_g)/dna_len*100
```

```{python}
# print the value
print(gc_percent)
```
For a cleaner view, and less decimals and more information at the time of viewing our output, the `print()` function can be of use. Here we have formatting elements of a string, the formatting characters are the **%** and the **f** in this case. The syntaxis is that the symbol **%** refers that a format will follow, then de **5** refers to the total number of digits, then the **.** and then the **3**; in this case it tells Python we only want 3 digits following the dot; finally, the **f** or any letter refers to the type of the value to format.

```{python}
print("The DNA sequence's GC content is %5.3f %%" % gc_percent)
```


For us to later use the same code again, instead of writing all over again, we can execute the code from a file. We write the code in the file and use the Python interpreter for it to execute the code as many times as we want. The files should have the **.py** extension for better location and identification of the Python files in the project. For it to run directly as a bash script, we can add the special header for our file to be executable.

```
#!/directory_where_python_is/python

# read DNA sequence from user
dna = "atcgtgatcgatgctagctagtagctagctgactagtcgatcgatcgtagc"

# count the number of C's in the DNA sequence
no_c = dna.count("c")

# count the number of G's in the DNA sequence
no_g = dna.count("g")

# determine the length of the DNA sequence
dna_len = len(dna)

# compute the GC percentage
gc_percent = (no_c+no_g)/dna_len*100

# print the value
print(gc_percent)
```
We can run the file directly from the interpreter by specifying the location and the name of the file within the prompt.

```
directory_location_whatever python file_name.py

```

Most probably, the file will have a problem since UNIX won't recognize it as an executable file. To fix this problem, we use the `chmod` command and the name of our file for it to be considered and executable program. There are also ways of executing the file directly from the Python interpreter. All this looks as follows.

```
chmod a+x file_name.py

directory_location_whatever ./file_name.py
```

On another note, comments are fundamental to understand what we see and what we tried to achieve in the code. Meaningful names and comments are invaluable for a cleaner and better code. An example looks like this.

```
#!/directory_where_python_is/python

# multiple lines of comments can be set with triple quotes
"""
This is my  first Python program.
It computes the GC content of a DNA sequence.
"""

# short comments can be done with the #

# read DNA sequence from user
dna = "atcgtgatcgatgctagctagtagctagctgactagtcgatcgatcgtagc"

# count the number of C's in the DNA sequence
no_c = dna.count("c")

# count the number of G's in the DNA sequence
no_g = dna.count("g")

# determine the length of the DNA sequence
dna_len = len(dna)

# compute the GC percentage
gc_percent = (no_c+no_g)/dna_len*100

# print the value
print(gc_percent)
```
## First Steps Toward Programming Part 4

The inputs for our programs may come from different sources. Up until now, the input has been manually given and done by ourselves, but it can be given by a series of sources such as other files or even the users. We can see an example of the latter as follows.

```{python}
# it will wait for the user to write something and will be assigned to the object "dna"
# dna = input("Enter a DNA sequence, please:")
dna = "tgactgactgac"
print(dna)
```

It is important to know that the input in this case will always give a string type object, we can later convert it as in the example below; but we must always remember it is initially a string.

```{python}
#give a number
# my_number = input("Please enter a number:")
my_number = "12"
```

```{python}
# check for data type
type(my_number)
```

```{python}
# make it into an actual number
actual_number = int(my_number)
```

```{python}
# Check for data type
type(actual_number)
```

We have other conversion functions into specific data types. They will be more useful along the way.

| Function               | Description                                  |
| ---------------------- | -------------------------------------------- |
| int(x [,base])         | Converts x to an integer                     |
| float(x)               | Converts x to a floating-point (real) number |
| complex(real [,imag])  | Creates a complex number                     |
| str(x)                 | Converts x to a string                       |
| chr(x)                 | Converts an integer to a character           |

# Module 2

## Data Structures Part 1

### Lists

It is an ordered set of values. We can have a list with different data types, not necessarily even numeric. We can make a list into a variable as follows.

```{python}

# we define it with brackets
gene_exp = ["gene", 5.18e-08, 0.00]

# access individual elements or intervals
gene_exp[:2]
```

We can access to different elements as any other variable, and starts with **0** rather than 1 when we start listing. Antoher interesting thing we can do with the list data types, is the modification of specific data within a previously created list.

```{python}

# the original list
gene_exp = ["gene", 5.18e-08, 0.00]

# replace the element and check it is there
gene_exp[0] = "lif"
gene_exp
```

We must be careful not to convert a string into a list, such as to change nucleotides in a sequence. This will return an error. Strings are **immutable**, unlike lists. 

We can slice the lists, and return just the list with the assigned elements from the original.

```{python}
# the original list
gene_exp = ["gene", 5.18e-08, 0.00, 0.00023042347, "twelve"]
```

```{python}
# slicing
gene_exp[-3:] #this will return all the elements after the third to last element in the list

```

We can also replace multiple elements of the list with just one new element and from the range we want, meaning specific locations within the list. It can be seen as follows.

```{python}
gene_exp

gene_exp[1:3] = [6.09e-02]
gene_exp
```

To concatenate lists, we use the **+** sign and create a new list that will have to be assigned to another variable. We can even clear a list by specifying all the positions and assigning nothing, just leave the brackets empty. 

```{python}
# Concatenate
list_1 = [234,43243, 0.000023404, "jknwfiujn"]

list_2 = gene_exp

list_1+list_2
```

```{python}
# empty a list
list_3 = list_1
list_3
list_3[:] = []
list_3
```

To delete specific elements in the list, the function `del` can be used to do this. **This will take effect immeadiately. overwriting the original list without having to re-assign**

```{python}
list_2
del list_2[1]
list_2
```

To work with lists as objects, we have several methods which yield different results and can be applied differently. Certain methods such as `.extend` can immediately add new elements. Method `.count` helps us count the number of times an element appears in a list. Other useful method is `.reverse`, which, as it is obviously implied, reverses the entire list.

```{python}
gene_exp
gene_exp.extend([23123, "hello"])
gene_exp
```

```{python}
gene_exp.count("lif")
gene_exp.count("gene")
```

```{python}
gene_exp
gene_exp.reverse()
```

The specific methods called `.append` and `pop` are of particular importance when using lists as stacks; meaning where the last element added is the first element retrieved (the first dish under the pile will be last cleaned, while the last will be the first).

An important difference between the `.append` and `.extend` methods, is that the first one will only add one element at a time, so even if you give a list, it will make it a single element inserted at the end of the list; the latter uses lists as arguments and adds many elements. 
```{python}
stack = ["a","b","c","d"]
```

```{python}
stack.append("e")
```

The method `.pop` can be used to retrieve the last element from a list, we pop it out. This method is also very powerful, as it will eliminate the last element immediately, just as the previous methods added elements in the same fashion.

```{python}
stack
elem = stack.pop()
elem
stack
```

To sort the elements of a list, we can use different functions, such as `sorted()` or even using the method list, which will directly change the order of the elements in the list. It doesn't have to be numbers, the letters will give priority to capital letters and alphabetical order. 

```{python}
list_t = [234,235,56,1,23,5]

sorted(list_t)

list_t.sort()
```

## Data Structures Part 2

### Tuples

A tuple consists of a number of values separated by commas, and is another standard sequence data type, like strings and lists. Their elements cannot be changed, therefore, they are immutable objects. The object can be created directly with or without brackets at the start and the end. They can be manipulated as lists, which can be sliced or indexed and are usually composed of heterogeneous sequence of elements. 

```{python}

t = 1,2,3
t
```

### Sets

This are unordered collections with no duplicate elements. They support mathematical operations like unions, intersections and differences. They can be lists with no replicate elements. These are created with the **{}** brackets, and can be used to check for similarities and differences alike.

```{python}
br_1 = {"gene","DNA","repair","like","math","wisdom"}

br_2 = {"gene","DNA","destroy","dislike","english","wisdom","wisdom"}
```

```{python}
# union
br_1 | br_2
```

```{python}
# intersection
br_1 & br_2
```

```{python}
# difference
br_1 - br_2
```

### Dictionaries

They can store things we want to look up later. It is an unordered set of key and value pairs, with the requirement that the keys are unique (within the dictionary). We associate values with specific keys for later retrieval. The keys can me any immutable data type and the values can be of any data type. Each key is defined, then we use the **:** to assign the value to the key; each key and its value is separated by a **,**.

```{python}
TF_motif = {"SP1":"gggcgg", "C/EBP":"attgcgcaat", "ATF":"tgacgtca", "c-Myc":"cacgtg", "Oct-1":"atgcaaat"}
```

To access a dictionary value within, we use a key within square brackets to obtain the value. Any key that is not annotated will yield an error message. The special word `in` can be used to know if the key is in the dictionary.

```{python}
TF_motif["ATF"]
```

We can add new keys and values by simply creating it the same way we search for the value in the dictionary, with the exception we have to give the value of the new key. 

```{python}
TF_motif

TF_motif["AP-1"] = "tgagtca"

TF_motif
```

To modify an existing key's value, we do the exact same process as adding a new key and value with the difference that in the squared brackets it should be written the name of the key value to update.

```{python}
TF_motif

TF_motif["AP-1"] = "tga(g/c)tca"

TF_motif
```

To delete an existing key, we use the function `del` which will act immediately.

```{python}
TF_motif

del TF_motif["SP1"]

TF_motif
```

To add whole dictionaries to the existing one, we can use the method `.update` and add the dictionary with the same rules as writing one from sratch. If there is a duplicate key, Python will select one to keep it from having duplicates.

```{python}
TF_motif

TF_motif.update({"SP1":"gggcgg", "C/EBP": "attgcgcaat", "Oct-1":"atgcaaa"})

TF_motif
```

To get a list of all our keys in the dictionary, we use the function `list` with the method `.keys` attached too.

```{python}
list(TF_motif.keys())
```

To get the values, we do the same thing with the difference of the used method; in this case we use `.values`.

```{python}
list(TF_motif.values())
```

## Ifs and Loops Part 1

Decision making will be specified with statements that evaluate the conditions that are given as input. The conditions will determine the path and may execute different sections of code or even stop the process immediately.

### IF statements

The conditions can be **TRUE** or **FALSE**, depending the conditions and the input we give. This will be evaluated directly by Python and will decide to execute the code or not depending on the conditions.

```{python}
# dna = input("Enter DNA sequence:")
dna = "ttgactgatggnnntgactgcn"

if "n" in dna:
  nbases = dna.count("n")
  print("dna sequence has %d undefined bases " % nbases)
```

The conditions in the if statements are Boolean expressions, meaning they deal in **T** or **F**, no in between. We can have functions and different conditions without the if statement itself, so we can actually work directly with the values.

```{python}
0>1
1<0
len("tgcatgac")<10
```

There are many expressions and operators that can be used in Boolean expressions.

|Comparison               | Operator |
| ----------------------- | -------- |
|Equal                    | ==       |
|not equal                | !=       |
|Less than                | <        |
|Greater than             | >        |
|Less than or equal to    | <=       |
|Greater than or equal to | >=       |

```{python}
"a" == "A"
"GT" != "AG"
"A" < "C"
10+1 == 11
```

Memberships operators like `in` and `not in` are very useful too to get Boolean values.

```{python}
dna = "atgctgtgacg"

"n" in dna

"n" not in dna
```

Now, identity operators can be useful too. They evaluate if variables on either side of the operator point to the same object or not; if we have the same object or not.

```{python}
alphabet = ["a","c","g","t"]

new_alph = alphabet[:]

new_alph == alphabet

new_alph is alphabet
```


For multiple conditions, the structure of `elif` is way more convenient; but if you only have a single option left, the operator `else` is better. The logical operators such as **AND**, **OR**, and **NOT** are also used in python for Boolean expressions. 

```{python}
dna = "tgctagcNNNtagctagcnntgactNNngann"

if "n" in dna or "N" in dna:
  nbases = dna.count("n") + dna.count("N")
  print("dna sequence has %d undefined bases " % nbases)
else: 
  print("dna sequence has no undefined bases")
```

## Ifs and Loops part 2

They are fundamental pieces in any programming language. It can execute a piece of code over and over again depending on the conditions. We have two basic loops that are used in most professional coding, **FOR** and **WHILE** loops.

### While

These loops will execute the code **while** the conditions remain true, so the conditions must change with each iteration; otherwise it will never get out and will continue to execute forever. 

Example: Given a DNA sequence, find the positions of all canonical donor splice site candidates in the sequence.

```{python}
dna = "tgctagctagcgtgtgtgtgttagctagtagctagctacncactngactgactgactgatcg"

pos = dna.find("gt",0)

while pos > -1:
  print("Donor splice site candidate at position %d" %pos)
  pos = dna.find("gt",pos+1)
```

### For loops

We iterate over the items of any sequence, like a list or string, in the order that they appear in the sequence.

```{python}
motifs = ["tagctagctagc","tgcatgctagctagctagctag","tagctagcat"]

for m in motifs:
  print(m,len(m))
```

To iterate over sequences of numbers, the function `range()` will facilitate this process. It is important to notice the range function also starts counting from element 0, so that if we ask for the first 4 elements in range 4, this will be the result.

```{python}
for i in range(4):
  print(i)
```

Example: Find if all characters in a given protein sequence are valid amino acids. 

```{python}
protein = "DVSUDVSVYHHRYQHRSHCRATWTVMMCJJ"

for i in range(len(protein)):
  if protein[i] not in "ABCDEFGHIKLMPQRSTVWXYZ":
    print("protein contains invalid amino acid %s at position %d" % (protein[i],i))
```

To end prematurely a loop, the kyword `break` is used to escape when a certain condition is met.

```{python}
protein = "DVSDUVSVYHHRYQHRSHCRATWTVMMCJJ"

for i in range(len(protein)):
  if protein[i] not in "ABCDEFGHIKLMPQRSTVWXYZ":
    print("this is not a valid protein sequence!")
    break
```

To continue the program to the next iteration without actually breaking and leaving the process, we use the `continue` statement. It will continue with the next iteration of the nearest enclosing loop, skipping the rest of the code in the loop. It can improve readability, eliminating some steps and unnecessary indentations.

Example: Delete all invalid amino acid characters from a protein sequence.

```{python}
protein = "DVSUDVSVYHHRYQHRSHCRATWTVMMCJJ"

corr_prot = ""

for i in range(len(protein)):
  if protein[i] not in "ABCDEFGHIKLMPQRSTVWXYZ":
    continue
  corr_prot = corr_prot+protein[i]

corr_prot
```

The `else` statement can be used in any loops. It will not execute if a `break` statetment come first.

Example: Find all prime numbers smaller than a given integer.

```{python}
N = 10

for y in range(2,N):
  for x in range(2,y):
    if y % x == 0:
      print(y, "equals", x, "*", y//x)
      break
  else:
    # loop fell through without finding a factor
    print(y, "is a prime number")
```

The `pass` statement is a placeholder, so it does nothing. Not that useful if you know exactly what you're doing, but it can help when just writing the first draft of the code. 

# Module 3

## Functions Part 1

They are fundamental to programming. They take a list of argument values, perform computations with said values and returns a single, or multiple, results. Some functions are *built-in*, like `print()` or `type()`, but we can create functions of our own design. The latter are called *user-defined functions*. These functions can be called any time we need them, therefore re-using the same code again and again; all of this while also allowing us to divide the work into sub-steps that are accomplished by each function. 

To define a function, we follow a general syntax that will look as follows.

[](images/Capture-1.webp)

Example: Create a function to compute the GC percentage of a DNA sequence.

```{python}
# define the function
# we can see the keyword "def" followed by the name "gc" and the argument "dna"
def gc(dna): 
  "this function computes the GC percentage of a DNA sequence"
  # we have indentation
  # count the unknown bases
  nbases = dna.count("n")+dna.count("N")
  
  # count the GC and make the according division
  gc_perc = float(dna.count("c")+dna.count("C")+dna.count("G")+dna.count("g"))*100/(len(dna)-nbases)
  
  # keep the values
  return gc_perc

gc("ttgatgatgtatatatcctatatnnnnnn")

```

The Scope of variable declaration refers to a variable inside a function that will only exist within the function itself. In the previous case, the variable `nbases` as well as `gc_perc`.

## Functions Part 2

We can return True or False values, meaning Boolean functions. They can be used as conditionals such as if or while whenever a condition is too complex.

Example: Write a program that checks if a given DNA sequence contains an in-frame stop codon.

```{python}
def has_stop(dna):
  stop_codon_found = False
  stop_codon = ["tga","tag","taa"]
  for i in range(0,len(dna),3):
    codon = dna[i:i+3].lower()
    if codon in stop_codons:
      stop_codon_found = True
      break
  return stop_codon_found
```

Now, lets make our function a little more robust. Since codons can be read with a certain degree of variance, meaning the frames might be a little up or down, we will make it so that we have an argument to specify where we start searching for the stop codons.

```{python}
def has_stop(dna,frame):
  stop_codon_found = False
  stop_codons = ["tga","tag","taa"]
  for i in range(frame,len(dna),3):
    codon = dna[i:i+3].lower()
    if codon in stop_codons:
      stop_codon_found = True
      break
  return stop_codon_found

dna = "tctgatgctgatgctagc"


has_stop(dna,0)
has_stop(dna,1)
has_stop(dna,2)
```

To assign default values to a function, such as 0 in our previously define function that searches for in-frame stop codons, we can do as follows. We must make sure our value from `frame` is set in the declaring of the function itself. 

```{python}
def has_stop(dna,frame=0):
  stop_codon_found = False
  stop_codons = ["tga","tag","taa"]
  for i in range(frame,len(dna),3):
    codon = dna[i:i+3].lower()
    if codon in stop_codons:
      stop_codon_found = True
      break
  return stop_codon_found
```

## Functions Part 3

We have passing function arguments, so the arguments are defined in the function. We can assign values with the order that the function is defined, or we can have the arguments named and the directly assign the values.

```{python}
seq = "tgctagctagc"

has_stop(seq,1)
has_stop(frame=2, dna=seq)
```

Example: Write a function to reverse complement a DNA sequence.

```{python}
seq = "TAGCTAGCTGACTGATCG"

def reverse_string(dna):
  dna = dna[::-1]
  return dna

def complement(dna):
  base_complement = {"A":"T", "C":"G","T":"A","G":"C","a":"t","t":"a","c":"g","g":"c","N":"N","n":"n"}
  letters = list(dna)
  letters = [base_complement[base] for base in letters]
  return "".join(letters)

def reverse_comp(dna):
  dna = reverse_string(dna)
  dna = complement(dna)
  return dna

reverse_comp(seq)
```

In the previous case we used the method `.join`, but we also have the method `.split`. We can provide the argument by which we want the method to act upon, such as specific characters or even spaces. This will yield either pieces or joined strings. In the example above, we decided we would join the letters with an empty string. 

## Modules and packages

### Modules

Modules are Python files with .py extensions, which contain definitions of functions and variables, usually related to a specific theme or objective. It is a form of grouping related code that make it easier to use and understand. We have created our first module as a sub directory, so we can see how to use modules following these steps. When calling for a module, it will search for built-in module, if it doesn't find it, it will search for a file with the specified name and the correct extension. We can use the `sys.path` variable from the sys built-in module to check the list of all directories where Python looks for files.

```{python}
import sys
sys.path
```

If the module's location doesn't pop up, we can use the method `append` to specify the directory.

```{python}
# CHANGE TO YOUR OWN LOCATION
sys.path.append("D:/Rs/Genomic-Data-Science-Specialization/Python_for_Genomic_Data_Science/modules/")

import dnautil
```

Now, if we tried to use one of the functions we created, such as `gc`, we would find it doesn't work. This is because it doesn't know we are extracting the function from the module, therefore, we must specify it.

```{python}
dna = "tagctagctagttttttc"

gc(dna)

dnautil.gc(dna)
```

If we want to avoid using the module's name, we can import all the names that a modules defines, meaning all the functions.

```{python}
from dnautil import *

dna = "tagctagctagtccccc"

gc(dna)
```

If we wish to import just a few functions we can select them by writing the functions names in stead of the asterisk.

### Packages

They're basically a way to group modules into a larger collection of modules. Each package is a directory which must contain a special file called **__init__.py**. This file can be empty, but it indicates that the directory it contains is a package, so it can be imported the same way a module can. We can see a package as follows.

```
bioseq\
  __init__.py
  dnautil.py
  rnautil.py
  proteinutil.py
  fasta\
    __innit__.py
    fastautil.py
  fastq\
    __innit__.py
    fastqutil.oy
  ...
```
In the example above, we see the package `bioseq` as the main directory, the package itself; followed by all the modules that this package is composed of. We can also import specific modules of the package instead of the whole package.

```
from bioseq import dnautil
```

# Module 4

## Communicating with the Outside Part 1

We want to read the data from file outside, sometimes they're quite big; so we don't write the file but read it. We will use the function `open(filename,mode)`. By default our parameter when using this function is `r`, which is the mode to read from a file.

```
f = open("myfile","r")

f = open("myfile")
```

To write into an already existing file, we use a different mode, being `a`. It is the way to append to the end of the file if it already exists; meanwhile, to create a file, the mode we use is `w`.

```
f = open("myfile","a")

f = open("myfile","w")
```
We can try to check if the file we're trying to access exists or is located where Python will recognize it. We use the special command `try` and can specify how to handle the situation if the file doesn't exist. This is just to avoid presenting an error message when trying to access an unexisting file. This way it will not crash, but rather just give us the message. 

```{python}
try:
  f = open("myfile")
except IOError:
  print("The file myfile does not exist!")
```

Now, we have an existing file with the name `myfile` in the **files** folder within the project. We will do the next examples using files in said folder. 
```{python}
# CHANGE TO YOUR FILE LOCATION
f = open('D:/Rs/Genomic-Data-Science-Specialization/Python_for_Genomic_Data_Science/files/myfile')
```

We will read in an efficient and fast way the file by looping on it as an object.

```{python}
for line in f:
  print(line)
```

Another way of reading the file is with the method `.seek()` to read the file. With `.seek` we can select a line from which will become the reference point, which in text can only be **0**; after this, we can use the method `.read()` to view the whole file. If we wish to see only the first line, the method `.readline()` can be used. 

```{python}
f.seek(0)
f.read()
```

```{python}
f.seek(0)
f.readline()
```

To write or append lines of text into our file, we must select the file and use the argument `a` when opening the file. After declaring our file as an object, we can now use the method `.write()` to append the desired string. If you're using Python 3.x it will return the length of the appended string. To close the file in order to free up the resources, we can close it, so it is important to use the method `.close` to do so.

```{python}
f = open('D:/Rs/Genomic-Data-Science-Specialization/Python_for_Genomic_Data_Science/files/myfile', 'a')

f.write('This is a third line of text')

f.close()
```

## Communicating with the Outside Part 2

We will now work with some FASTA files that contain some real DNA sequences. They have a header and the sequences themselves.

Exercise: Build a dictionary containing all sequences from a FASTA file.

We want to open the file, then read each line one by one, ask it if is a header; if it is, use it as the name of the sequence, if it isn't then update the sequence in the dictionary. When we end the sequence we want to loop until the file ends and we can close the file. 

```{python}
try:
  f = open("D:/Rs/Genomic-Data-Science-Specialization/Python_for_Genomic_Data_Science/files/myfile.fa")
except IOError:
  print("The file myfile.fa does not exist!")
```

We will start with the main loop, which will create the dictionary itself.

```{python}
seqs = {}
for line in f:
  # let us discard the newline at the end (if any)
  line = line.rstrip()
  #distinguish header from sequence
  if line[0]=='>': # or line.startswith('>')
    words=line.split()
    name=words[0][1:]
    seqs[name]=''
  else: # sequence, not a header
    seqs[name] = seqs[name]+line
    
f.close
```

## Communicating with the Outside Part 3

We can retrieve data from dictionaries! To retrieve the key and the corresponding values from the dictionary, we use the `.items()` method.

```{python}
for name,seq in seqs.items():
  print(name,seq)
```

### Command Line Arguments

Scripts often need to process command line arguments. Suppose a script that parses a FASTA file is called `processfasta.py` and you want to run it on a file whose name we give as an argument in the command line. 

```
>python processfasta.py myfile.fa
```

The arguments of the above command are stored in the sys module's argv attribute as a list.

```
>>> import sys

>>> print(sys.argv)

['processfasta.py','myfile.fa']
```

```{bash}
cd files
python3 processfasta.py myfile.fa
```


Once we are processing arguments in a program, we may even want for some arguments to be optional or some to be required. With this, Python's `getopt` module can help with processing the arguments of sys.argv. Suppose the processfasta.py script reads a FASTA file but only stores in the dictionary the sequences bigger than a given length provided in the command line.

To do this, we must make the usage definition for our processfasta.py file. We can do it directly in bash as follows. We want to define it so users can understand what we're doing. This will define the arguments and what each and every single one does.

```
def usage():
  print """
processfasta.py : reads a Fasta file and builds a dictionary with all sequences bigger than a given length

processfasta.py [-h] [-l <length>] <filename>

-h            print this message

-l <length>   filter all sequences with a length smaller than <length> (default <length>=0)

<filename>    the file has to be in FASTA formal

    """
```

We will add this in now with Python.

```{python}
import sys
import getopt
def usage():
  print ("""
processfasta.py : reads a Fasta file and builds a dictionary with all sequences bigger than a given length

processfasta.py [-h] [-l <length>] <filename>

-h            print this message

-l <length>   filter all sequences with a length smaller than <length> (default <length>=0)

<filename>    the file has to be in FASTA formal

    """)

o, a = getopt.getopt(sys.argv[1:], 'l:h')
opts = {}
seqlen=0;

for k,v in o:
  opts[k] = v
  
if '-h' in opts.keys():
  usage(); sys.exit()
  
#if len(a) < 1:
#  usage(); sys.exit("input fasta file is missing")
  
if '-l' in opts.keys():
  if int(opts['l'])<0 :
    print("Length of sequence should be positive!!"); sys.exit(0)
  seqlen=opts['-l']
```

### Using the System Environment

When we run a script in UNIX environment, standard streams are recognized by a computer program.

- `stdin` is the standard input. It is a stream of data, often text, going into a program. Unless redirected, standard input is expected from the keyboard which started the program. Is is an alternative of opening a file. 
- `stdout` is standard output. It is the stream where a program writes its output data. Unless redirected, standard output is the text terminal in which initiated the program. 
- `stderr` (standard error) is another output stream typically used by programs to output error messages or diagnostics. It is a stream independent of standard output and can provide error messages even when `stdout` has been redirected. `stderr` can also be redirected separately. An example is as follows.

```
my_program_ | my_script.sh 1>program_output.txt 2>error_messages.txt
```

### Using the System Environment [cont'd]

The sys module in Python provides file handles for the standard input, output, and error. After starting the handle, Python awaits for input, so we can write whatever we want. To close, we need a special character to end the input. 

```
>>> sys.stdin.read()
a line
another line

'a line\nanother line\n'
```
**We exit pressing ctrl+d**

In the same way, we can use `stdout` to get our desired output.

```{python}
sys.stdout.write("Some useful output.\n")
```

To write the standard error, it is the same formula.

```{python}
sys.stderr.write("Warning: input file was not found\n")
```

### Interfacing with External Programs

You can call/execute an external program from your script. It helps us automate certain tasks that would be difficult to do just with Python. We can even use the function `call()` from the default module `subprocess`. This allow us to run an external program.

## Biopython

It is a project with modules and scripts available for  bioinformatics. It is Python-based free software that can be easily downloaded from [here](http://www.biopython.org). It's goal is to make Python easier for any user, as it includes parsers for various bioinformatics file formats, access to online services (NCBI, PubMed, etc.), interfaces to common bioinformatics programs such as BLAST, ClustalW, and others. **It also contains documentation!!**

To check if Biopython is installed, we can try the following code.

```{python}
import Bio
```

To check the version we're using, we can use this code line.

```{python}
print(Bio.__version__)
```

If it is not downloaded, as it is most likely, we can install it following the [instructions](http://biopython.org/wiki/Download) that are within the site. We can download it no matter the OS and is supported by Python 2 and Python 3 alike. 

To see how Biopython can help us, lets put it into action. We will find out from what species an unknown DNA sequence came from. We will be using an interface in order to access to BLAST. We call it directly via Biopython; we use the specific methods from the module `Blast` that is within the Biopython project. 

```{python}
from Bio.Blast import NCBIWWW
fasta_string = open("D:/Rs/Genomic-Data-Science-Specialization/Python_for_Genomic_Data_Science/files/myseq.fa").read()
result_handle = NCBIWWW.qblast("blastn","nt",fasta_string)
```

We can search for more options in the `NCBI.qblast()` function by usign the `help()` function.

Now, to actually visualize and format the previous output, we use different functions from Biopython that will help us read the data. It is important to know that the previous object is an .xml file by default, so that is what we're working with.

```
from Bio.Blast import NCBIXML
blast_record = NCBIXML.read(result_handle)
```

Now, for it to be readable, we will be parsing our output. For example, by only showing those matches that comply with a specific E value threshold. We will loop through each of the alignments that actually interest us. 

![](D:/Rs/Genomic-Data-Science-Specialization/Python_for_Genomic_Data_Science/images/script_blast.png)
![](D:/Rs/Genomic-Data-Science-Specialization/Python_for_Genomic_Data_Science/images/result_blast.png)

For more information on Biopython, we can consult the [cookbook](http://biopython.org/DIST/docs/tutorial/Tutorial.html) and the [FAQ](http://biopython.org/DIST/docs/tutorial/Tutorial.html#htoc5)





