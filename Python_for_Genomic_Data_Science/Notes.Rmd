---
title: "Python for Genomic Data Science"
author: "Jorge Luis GÃ³mez"
date: "`r Sys.Date()`"
output:
  html_document: 
    fig_height: 8
    fig_width: 13
    number_section: yes
    theme: cerulean
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
  pdf_document:
    toc: yesT
  word_document:
    toc: yes
---
# Resources

1. We can work directly with the SandBox service Coursera offers completely free with the course. It is available at [this](https://www.coursera.org/learn/python-genomics/lab-sandbox?path=%2Ftree) location.

2. The official [Python](https://www.python.org) site.

3. A tutorial by Patrick O'Brien named "Beginning Python for Bioinformatics".

4. Introduction to Programming using Python by the Pasteur Institute

5. An interactive site for learning [Python](https://learnpython.org)

6. The book "Think Python" 2nd Edition by Allen B. Downey which can be found [here](Think Python 2nd Edition by Allen B. Downey)

# Module 1

## Overview of Python

The approaches of learning how to program can be as diverse as taking classes, asking for help, read a book, or even read someone else's code. There are some programming strategies we can follow.

- Identify the inputs and data specification
- Provide all the data and design how and which steps the computer will follow
- Decide the output you want to have, what we want to be displayed
- Refine the program and give more details
- Actually write the program

The more complex programs can be designed with a little more ease if you apply some strategies such as writing a pseudo code. A pseudo code has normal text and semantics, but will try to describe the process our final code will execute.

Python is an actual programming language. It is very popular and it is easy to learn compared to other languages. It has efficient data structures and simple object-oriented programming, making it more accessible. A very important feature is that is is an interpreted language, meaning it will not have to compile before executing it; we run it directly from our line of code; the drawback is that due to the nature of being interpreted, the speed will be an issue.

Python is easy and simple to use, having a more simple and defined syntax that makes it readable; it will also be shorter than other languages. As said before, it is an interpreted language. It has lots of built-in functions and libraries available. It can run regardless of the used OS in the computer. It can be used as an extension language that communicates, for example, with more complex programs in other languages. It can also be used for both large and complex tasks, as well as simple ones. 

## First Steps Toward Programming Part 1

We'll start with the basics, the `numbers` and `string` data types.

Firstly, we'll learn how to use python as a computer, since it has some important differences, for example, to the language R. 

### Numbers

```{python}
# For adding, we can do it directly
5+5
```

```{python}
# The * means multiplication
10*2
```

```{python}
# Double * represents powers
10**2
```

```{python}
# Double // only yields the integer without the fractional part of a division
17//3
```

```{python}
# The % operator will return just the remainder after a division
15%2

# Python follows mathematical languages, so that, for example * takes precedence before +,-
```

Numbers have different types, like integers, which are just round numbers; but we can have real numbers with fractions, etc. We can check the number types with specific commands in Python.

```{python}
# Integers
type(5)
```

```{python}
# real numbers
type(3.5) # it will have the name 'float' which refers to numbers with fractions
```

```{python}
# complex numbers
type(3+2j)
```

### Strings

They are specific data structures used in genomic sciences since, for example, the genomic code is a string of the same 4 different characters. We can create strings with single or double quotes like this **"",'' **. The most common use is double quotes when using normal speech. To avoid errors with single quotes, for a character not to be counted as the end of the string, we add a **/** before the character itself. For multiple lines of characters to be considered as a single string, we can ad triple quotes before writing, and the the same after the lines themselves; each triple quotes on their own lines ('''    ''').

Another interesting thing is the use of escape characters, which give special meanings to lines depending on how you use the. For example.

| Construct    | Meaning     |
| ------------ | ----------- |
| \\n          | New line    |
| \\t          | Tab         |
| \\\          | Backslash   |
| \\"          | Double quote|

In order to print more nicely, we can use the command `print()` in order to produce more readable outputs by omitting and enclosing quotes by printing escaped and special characters. It can be shown as follows.

```{python}
print(""" 
>dna1
actgactgatgctgctgatgc
tagctgatcgtagctgc
>dna2
tgactgatcgatgctgacttgactgtgac
""")
```

Without the backslash at the end of the first triple quotes, the end of a line is directly included into the string. 

### Basic operators

We have a myriad of operators for us to manipulate the strings as we want.

```{python}
# concatenate strings
"atg"+"ctg"
```

```{python}
# copy/replicate strings
"atg"*3
```

```{python}
# membership: true if first string exist inside the second string
"atg" in "tatgtcgagtatgctgatatg"
```

```{python}
# non-membership: true if the first string does not exist in the second one
"atg" in "my name is luis"
```

## First Steps Towards Programming Part 2

### Variables

Variables are the *storage containers* for our data, no matter the type or structure. The **=** sign is used to assign a value to a variable.

```{python}
codon = "atg"

dna_sequence = "atgctgctgatgtgctga"
```

As shown, if if is not order to Python, then it will not return the values we assigned to our variables, meaning they exist, but are not shown. In the same fashion, typing an unexisting/undefined name of a variable will just send an error. We can change the values to the same variable, which can overwrite the value, or even copy the value from a variable into another.

```{r}
a = 4
a

b = a
b

b = b+3
b
```

Generally speaking, the name of the variables must have meaningful names, so it can be understood by others and yourself in later times. Python is case-sensitive, so we must pay attention when defining our variables. We have to account that some characters cannot be used in the variables' names, such as special characters and numbers as the first character of the variable's name.

We can also try to find specific positions or locations of a string without having to print the whole string. Indexing refers to selecting the character at position *x* that has been selected. Slicing refers to making a substring form the original between the selected *x* and *y* positions. It is important to note that the string in Python, and some other languages, start at number 0 rather than 1.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna[0]
dna[0:3]
dna[:3]
dna[2:]
```

In the previous slicing example, we want to select the first 3 characters from our string. We may think it would consider the first 4 characters since we begin in 0, but the 3 at the end of the slice means it will take everything **before** the specified end of the slice. 

We can also select negative numbers, which start counting from the right, meaning the end of the string.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

# the last character
dna[-1]
```

When we wish to know the length of our strings, we can use the function `len()` to directly return the length. 

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

len(dna)
```

There are many other functions that can be used for a variety of reasons and scenarios, such as `type()` and `print()`. If any questions arise and we need more information about the function, we can simply type `help(name_of_function)` and it will give us more information.

Our variables are objects too, so we can make more with them. Specific functions and actions can be performed onto our variables, these are called *methods*. For example, we can use the function `name_of_variable.count()` to count how many times does a character repeat itself in the string.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna.count("c")
dna.count("gc")
```

Other examples include the change of lower-case to upper-case characters and vice-versa. Even finding substring can be done with the method `.find()`, this will yield the position in which the specified substring starts in the original, but only the first one; we can change where it starts looking with parameters, even starting from the end.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna.upper()

dna.find("atgc")
dna.find("atcg",11)
dna.rfind("tta")
```

Other functions do not modify the string, but analyse what it contains and gives us more information. To exemplify, the functions `.islower()` and `.isupper()` both will tell us if our string complies with the rules, in this case, if the string is in upper or lower-case letters.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna.islower()
dna.isupper()
```

Another useful string method is replacing certain characters for others.

```{python}
dna = "ttagctgactgatgcgctagctagctgactgatcg"

dna.replace("a","A")
```

## First Steps Toward Programming Part 3

We'll make the first program using Python in this lecture. Starting from the creation of the pseudo code that will later be translated into actual code for us to determine the GC's concentration in a string. First of all, we'll declare the "dna" variable which will contain the sequence in question.

```{python}
# read DNA sequence from user
dna = "atcgtgatcgatgctagctagtagctagctgactagtcgatcgatcgtagc"
```

```{python}
# count the number of C's in the DNA sequence
no_c = dna.count("c")
```

```{python}
# count the number of G's in the DNA sequence
no_g = dna.count("g")
```

```{python}
# determine the length of the DNA sequence
dna_len = len(dna)
```

```{python}
# compute the GC percentage
gc_percent = (no_c+no_g)/dna_len*100
```

```{python}
# print the value
print(gc_percent)
```
For a cleaner view, and less decimals and more information at the time of viewing our output, the `print()` function can be of use. Here we have formatting elements of a string, the formatting characters are the **%** and the **f** in this case. The syntaxis is that the symbol **%** refers that a format will follow, then de **5** refers to the total number of digits, then the **.** and then the **3**; in this case it tells Python we only want 3 digits following the dot; finally, the **f** or any letter refers to the type of the value to format.

```{python}

print("The DNA sequence's GC content is %5.3f %%" % gc_percent)
```


For us to later use the same code again, instead of writing all over again, we can execute the code from a file. We write the code in the file and use the Python interpreter for it to execute the code as many times as we want. The files should have the **.py** extension for better location and identification of the Python files in the project. For it to run directly as a bash script, we can add the special header for our file to be executable.

```
#!/directory_where_python_is/python

# read DNA sequence from user
dna = "atcgtgatcgatgctagctagtagctagctgactagtcgatcgatcgtagc"

# count the number of C's in the DNA sequence
no_c = dna.count("c")

# count the number of G's in the DNA sequence
no_g = dna.count("g")

# determine the length of the DNA sequence
dna_len = len(dna)

# compute the GC percentage
gc_percent = (no_c+no_g)/dna_len*100

# print the value
print(gc_percent)
```
We can run the file directly from the interpreter by specifying the location and the name of the file within the prompt.

```
directory_location_whatever python file_name.py

```

Most probably, the file will have a problem since UNIX won't recognize it as an executable file. To fix this problem, we use the `chmod` command and the name of our file for it to be considered and executable program. There are also ways of executing the file directly from the Python interpreter. All this looks as follows.

```
chmod a+x file_name.py

directory_location_whatever ./file_name.py
```

On another note, comments are fundamental to understand what we see and what we tried to achieve in the code. Meaningful names and comments are invaluable for a cleaner and better code. An example looks like this.

```
#!/directory_where_python_is/python

# multiple lines of comments can be set with triple quotes
"""
This is my  first Python program.
It computes the GC content of a DNA sequence.
"""

# short comments can be done with the #

# read DNA sequence from user
dna = "atcgtgatcgatgctagctagtagctagctgactagtcgatcgatcgtagc"

# count the number of C's in the DNA sequence
no_c = dna.count("c")

# count the number of G's in the DNA sequence
no_g = dna.count("g")

# determine the length of the DNA sequence
dna_len = len(dna)

# compute the GC percentage
gc_percent = (no_c+no_g)/dna_len*100

# print the value
print(gc_percent)
```
## First Steps Toward Programming Part 4

The inputs for our programs may come from different sources. Up until now, the input has been manually given and done by ourselves, but it can be given by a series of sources such as other files or even the users. We can see an example of the latter as follows.

```{python}

# it will wait for the user to write something and will be assigned to the object "dna"
dna = input("Enter a DNA sequence, please:")
print(dna)
```

It is important to know that the input in this case will always give a string type object, we can later convert it as in the example below; but we must always remember it is initially a string.

```{python}

#give a number
my_number = input("Please enter a number:")
```

```{python}
# check for data type
type(my_number)
```

```{python}
# make it into an actual number
actual_number = int(my_number)
```

```{python}
# Check for data type
type(actual_number)
```

We have other conversion functions into specific data types. They will be more useful along the way.

| Function               | Description                                  |
| ---------------------- | -------------------------------------------- |
| int(x [,base])         | Converts x to an integer                     |
| float(x)               | Converts x to a floating-point (real) number |
| complex(real [,imag])  | Creates a complex number                     |
| str(x)                 | Converts x to a string                       |
| chr(x)                 | Converts an integer to a character           |

# Module 2

## Data Structures Part 1

### Lists

It is an ordered set of values. We can have a list with different data types, not necessarily even numeric. We can make a list into a variable as follows.

```{python}

# we define it with brackets
gene_exp = ["gene", 5.18e-08, 0.00]

# access individual elements or intervals
gene_exp[:2]
```

We can access to different elements as any other variable, and starts with **0** rather than 1 when we start listing. Antoher interesting thing we can do with the list data types, is the modification of specific data within a previously created list.

```{python}

# the original list
gene_exp = ["gene", 5.18e-08, 0.00]

# replace the element and check it is there
gene_exp[0] = "lif"
gene_exp
```

We must be careful not to convert a string into a list, such as to change nucleotides in a sequence. This will return an error. Strings are **immutable**, unlike lists. 

We can slice the lists, and return just the list with the assigned elements from the original.

```{python}
# the original list
gene_exp = ["gene", 5.18e-08, 0.00, 0.00023042347, "twelve"]
```

```{python}
# slicing
gene_exp[-3:] #this will return all the elements after the third to last element in the list

```

We can also replace multiple elements of the list with just one new element and from the range we want, meaning specific locations within the list. It can be seen as follows.

```{python}
gene_exp

gene_exp[1:3] = [6.09e-02]
gene_exp
```

To concatenate lists, we use the **+** sign and create a new list that will have to be assigned to another variable. We can even clear a list by specifying all the positions and assigning nothing, just leave the brackets empty. 

```{python}
# Concatenate
list_1 = [234,43243, 0.000023404, "jknwfiujn"]

list_2 = gene_exp

list_1+list_2
```

```{python}
# empty a list
list_3 = list_1
list_3
list_3[:] = []
list_3
```

To delete specific elements in the list, the function `del` can be used to do this. **This will take effect immeadiately. overwriting the original list without having to re-assign**

```{python}
list_2
del list_2[1]
list_2
```

To work with lists as objects, we have several methods which yield different results and can be applied differently. Certain methods such as `.extend` can immediately add new elements. Method `.count` helps us count the number of times an element appears in a list. Other useful method is `.reverse`, which, as it is obviously implied, reverses the entire list.

```{python}
gene_exp
gene_exp.extend([23123, "hello"])
gene_exp
```

```{python}
gene_exp.count("lif")
gene_exp.count("gene")
```

```{python}
gene_exp
gene_exp.reverse()
```

The specific methods called `.append` and `pop` are of particular importance when using lists as stacks; meaning where the last element added is the first element retrieved (the first dish under the pile will be last cleaned, while the last will be the first).

An important difference between the `.append` and `.extend` methods, is that the first one will only add one element at a time, so even if you give a list, it will make it a single element inserted at the end of the list; the latter uses lists as arguments and adds many elements. 
```{python}
stack = ["a","b","c","d"]
```

```{python}
stack.append("e")
```

The method `.pop` can be used to retrieve the last element from a list, we pop it out. This method is also very powerful, as it will eliminate the last element immediately, just as the previous methods added elements in the same fashion.

```{python}
stack
elem = stack.pop()
elem
stack
```

To sort the elements of a list, we can use different functions, such as `sorted()` or even using the method list, which will directly change the order of the elements in the list. It doesn't have to be numbers, the letters will give priority to capital letters and alphabetical order. 

```{python}
list_t = [234,235,56,1,23,5]

sorted(list_t)

list_t.sort()
```

## Data Structures Part 2

### Tuples

A tuple consists of a number of values separated by commas, and is another standard sequence data type, like strings and lists. Their elements cannot be changed, therefore, they are immutable objects. The object can be created directly with or without brackets at the start and the end. They can be manipulated as lists, which can be sliced or indexed and are usually composed of heterogeneous sequence of elements. 

```{python}

t = 1,2,3
t
```

### Sets

This are unordered collections with no duplicate elements. They support mathematical operations like unions, intersections and differences. They can be lists with no replicate elements. These are created with the **{}** brackets, and can be used to check for similarities and differences alike.

```{python}
br_1 = {"gene","DNA","repair","like","math","wisdom"}

br_2 = {"gene","DNA","destroy","dislike","english","wisdom","wisdom"}
```

```{python}
# union
br_1 | br_2
```

```{python}
# intersection
br_1 & br_2
```

```{python}
# difference
br_1 - br_2
```

### Dictionaries

They can store things we want to look up later. It is an unordered set of key and value pairs, with the requirement that the keys are unique (within the dictionary). We associate values with specific keys for later retrieval. The keys can me any immutable data type and the values can be of any data type. Each key is defined, then we use the **:** to assign the value to the key; each key and its value is separated by a **,**.

```{python}
TF_motif = {"SP1":"gggcgg", "C/EBP":"attgcgcaat", "ATF":"tgacgtca", "c-Myc":"cacgtg", "Oct-1":"atgcaaat"}
```

To access a dictionary value within, we use a key within square brackets to obtain the value. Any key that is not annotated will yield an error message. The special word `in` can be used to know if the key is in the dictionary.

```{python}
TF_motif["ATF"]
```

We can add new keys and values by simply creating it the same way we search for the value in the dictionary, with the exception we have to give the value of the new key. 

```{python}
TF_motif

TF_motif["AP-1"] = "tgagtca"

TF_motif
```

To modify an existing key's value, we do the exact same process as adding a new key and value with the difference that in the squared brackets it should be written the name of the key value to update.

```{python}
TF_motif

TF_motif["AP-1"] = "tga(g/c)tca"

TF_motif
```

To delete an existing key, we use the function `del` which will act immediately.

```{python}
TF_motif

del TF_motif["SP1"]

TF_motif
```

To add whole dictionaries to the existing one, we can use the method `.update` and add the dictionary with the same rules as writing one from sratch. If there is a duplicate key, Python will select one to keep it from having duplicates.

```{python}
TF_motif

TF_motif.update({"SP1":"gggcgg", "C/EBP": "attgcgcaat", "Oct-1":"atgcaaa"})

TF_motif
```

To get a list of all our keys in the dictionary, we use the function `list` with the method `.keys` attached too.

```{python}
list(TF_motif.keys())
```

To get the values, we do the same thing with the difference of the used method; in this case we use `.values`.

```{python}
list(TF_motif.values())
```

## Ifs and Loops Part 1

Decision making will be specified with statements that evaluate the conditions that are given as input. The conditions will determine the path and may execute different sections of code or even stop the process immediately.

### IF statements

The conditions can be **TRUE** or **FALSE**, depending the conditions and the input we give. This will be evaluated directly by Python and will decide to execute the code or not depending on the conditions.

```{python}
dna = input("Enter DNA sequence:")

if "n" in dna:
  nbases = dna.count("n")
  print("dna sequence has %d undefined bases " % nbases)
```

The conditions in the if statements are Boolean expressions, meaning they deal in **T** or **F**, no in between. We can have functions and different conditions without the if statement itself, so we can actually work directly with the values.

```{python}
0>1
1<0
len("tgcatgac")<10
```

There are many expressions and operators that can be used in Boolean expressions.

|Comparison               | Operator |
| ----------------------- | -------- |
|Equal                    | ==       |
|not equal                | !=       |
|Less than                | <        |
|Greater than             | >        |
|Less than or equal to    | <=       |
|Greater than or equal to | >=       |

```{python}
"a" == "A"
"GT" != "AG"
"A" < "C"
10+1 == 11
```

Memberships operators like `in` and `not in` are very useful too to get Boolean values.

```{python}
dna = "atgctgtgacg"

"n" in dna

"n" not in dna
```

Now, identity operators can be useful too. They evaluate if variables on either side of the operator point to the same object or not; if we have the same object or not.

```{python}
alphabet = ["a","c","g","t"]

new_alph = alphabet[:]

new_alph == alphabet

new_alph is alphabet
```


For multiple conditions, the structure of `elif` is way more convenient; but if you only have a single option left, the operator `else` is better. The logical operators such as **AND**, **OR**, and **NOT** are also used in python for Boolean expressions. 

```{python}
dna = "tgctagcNNNtagctagcnntgactNNngann"

if "n" in dna or "N" in dna:
  nbases = dna.count("n") + dna.count("N")
  print("dna sequence has %d undefined bases " % nbases)
else: 
  print("dna sequence has no undefined bases")
```

## Ifs and Loops part 2

They are fundamental pieces in any programming language. It can execute a piece of code over and over again depending on the conditions. We have two basic loops that are used in most professional coding, **FOR** and **WHILE** loops.

### While

These loops will execute the code **while** the conditions remain true, so the conditions must change with each iteration; otherwise it will never get out and will continue to execute forever. 

Example: Given a DNA sequence, find the positions of all canonical donor splice site candidates in the sequence.

```{python}
dna = "tgctagctagcgtgtgtgtgttagctagtagctagctacncactngactgactgactgatcg"

pos = dna.find("gt",0)

while pos > -1:
  print("Donor splice site candidate at position %d" %pos)
  pos = dna.find("gt",pos+1)
```

### For loops

We iterate over the items of any sequence, like a list or string, in the order that they appear in the sequence.

```{python}
motifs = ["tagctagctagc","tgcatgctagctagctagctag","tagctagcat"]

for m in motifs:
  print(m,len(m))
```

To iterate over sequences of numbers, the function `range()` will facilitate this process. It is important to notice the range function also starts counting from element 0, so that if we ask for the first 4 elements in range 4, this will be the result.

```{python}
for i in range(4):
  print(i)
```

Example: Find if all characters in a given protein sequence are valid amino acids. 

```{python}
protein = "DVSUDVSVYHHRYQHRSHCRATWTVMMCJJ"

for i in range(len(protein)):
  if protein[i] not in "ABCDEFGHIKLMPQRSTVWXYZ":
    print("protein contains invalid amino acid %s at position %d" % (protein[i],i))
```

To end prematurely a loop, the kyword `break` is used to escape when a certain condition is met.

```{python}
protein = "DVSDUVSVYHHRYQHRSHCRATWTVMMCJJ"

for i in range(len(protein)):
  if protein[i] not in "ABCDEFGHIKLMPQRSTVWXYZ":
    print("this is not a valid protein sequence!")
    break
```

To continue the program to the next iteration without actually breaking and leaving the process, we use the `continue` statement. It will continue with the next iteration of the nearest enclosing loop, skipping the rest of the code in the loop. It can improve readability, eliminating some steps and unnecessary indentations.

Example: Delete all invalid amino acid characters from a protein sequence.

```{python}
protein = "DVSUDVSVYHHRYQHRSHCRATWTVMMCJJ"

corr_prot = ""

for i in range(len(protein)):
  if protein[i] not in "ABCDEFGHIKLMPQRSTVWXYZ":
    continue
  corr_prot = corr_prot+protein[i]

corr_prot
```

The `else` statement can be used in any loops. It will not execute if a `break` statetment come first.

Example: Find all prime numbers smaller than a given integer.

```{python}
N = 10

for y in range(2,N):
  for x in range(2,y):
    if y % x == 0:
      print(y, "equals", x, "*", y//x)
      break
  else:
    # loop fell through without finding a factor
    print(y, "is a prime number")
```

The `pass` statement is a placeholder, so it does nothing. Not that useful if you know exactly wht you're doing, but it can help when just writing the first draft of the code. 

# Module 3

## Functions Part 1



```{python}
mylist=[1,2,2,3,4,5]

d = {}
result = False
for x in mylist:
  if not x in d:
    d[x]=True
    continue
  result = True

print(result)
print(d)

mylist=[1,2,2,3,4,5]

d = {}
result = False
for x in mylist:
  if x in d:
    result=True
    break
  d[x] = True

print(result)
print(d)
```









